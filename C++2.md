#泛型函数（模板函数）
参数和返回值类型不确定时使用。   
在使用它们的时候我们是知道类型的，把参数传给泛型函数，这样泛型函数的泛型参数类型就会<font color=red>自动确定</font>下来了。   
模板的类型参数是根据参数类型而被推断出来的。   
模板函数让我们有能力编写<font color=red>数据结构独立</font>的程序。

	template<class T>
	T median(vector<T> v) {
		typedef typename vector<T>::size_type vec_sz;
	
		vec_sz size = v.size();
		if (size == 0) {
			throw domain_error("median an empty vector");
		}
	
		sort(v.begin(), v.end());
	
		vec_sz mid = size / 2;
		return size % 2 == 0 ? (v[mid] + v[mid - 1]) / 2: v[mid];
	}

> T 是一个类型参数，表示一个<font color=red>类型</font>，跟普通参数表示数值是类似的。  
> 调用这个函数的时候，系统会在编译期间把它判定的类型赋给这个T   
> <font color=red>**`typename`**</font>关键字是为了让系统知道`vector<T>::size_type` 应该被当做一个类型来处理，在模板函数中使用这些类型都必须使用 `typename` ，因为有些系统环境并不了解标准库

###模板实例化
如果我们对vector<int>类型调用median,系统环境将高效地创建并编译这个函数的一个实例，它会用 `int` 来代替所有对 `T` 的使用。    
C++标准没有规定实例化的实现细节，因此每种系统环境可以有自己的实现   

> 为了对一个模板进行实例化，系统环境要求这个模板的定义（而不仅仅是声明）必须是系统环境可以访问的。这意味着，定义了模板的源文件和头文件都必须是可访问的。源文件的定位方式由具体的系统环境来决定，许多系统都要求模板的头文件间直接或通过#include指令而把源文件包含进来。因此**<font color=red>对于模板函数的定义和声明，一般都放在 `头文件 ` 中 </font>**

#iterator 
库定义了五种迭代器（iterator categories），其中的每一种都对应于一个特定的迭代器操作集合。